<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title>CrypticOS Playground</title>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<select id="programSelector" class="top">
			<option>std.casm</option>
		</select>
		<input id="input" class="top" value=".+0">
		<textarea id="code" onkeydown="if(event.keyCode===9){var v=this.value,s=this.selectionStart,e=this.selectionEnd;this.value=v.substring(0, s)+'\t'+v.substring(e);this.selectionStart=this.selectionEnd=s+1;return false;}"></textarea>
		<textarea id="output"></textarea>
		<button onclick="compileAsm()">Compile</button>
		<button onclick="compileRun()">Run & Compile</button>
		<select id="speedSelector">
			<option>fast</option>
			<option>slow</option>
		</select>
	</body>
	<script type="text/javascript" src="emulator.js"></script>
	<script type="text/javascript" src="compile.js"></script>
	<script>
	var code = document.getElementById("code");
	var output = document.getElementById("output");
	var input = document.getElementById("input");

	function compileAsm() {
		var asm = compile(code.value.split("\n"));
		console.log(asm);
		output.value = "";
		output.value += asm;
		return asm;
	}

	function compileRun() {
		runCode(compileAsm());
	}

	function runCode(brainflake) {
		var mem = {
			top: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			topP: 0,
			bottom: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			bottomP: 0
		};

		output.value += "\n-> Interpreter Result:\n";
		execute(mem, brainflake, speedSelector.value);
	}

	document.getElementById("programSelector").onchange = function() {
		code.value = demos[this.value];
	}

	// Raw string demos. Yay, messy me.
	var demos = {
		"std.casm": `; CrypticOS Kernel / Internal standard function library

; operation:
; 1 = store char
; 2 = get char
; Function parameters
var std_third 0
var std_second 0
var std_first 0

var std_result 0 ; Output variable
var std_i 0 ; General purpose incremental variable

jmp std_end ; jmp program start

; std_first = operation
; std_second = location
; std_third = value to set/get
char:
	inl "d<<<^>>>" ; Reserve for operation
	inl "d<<<<^>>>>" ; reserve for location
	inl "d<<<<<^>>>>>d" ; Reserve for value to set or value to get
	inl "d" ; reserve for temp
	inl "d" ; reserve for label, set in loop (label)
	inl "!^d" ; store zero to compare (value1)
	inl "aaaaavddddd^" ; store value from fourth cell (value2)
	inl "aa" ; go back
	char_back:
		inl "a^d" ; store current cell temp
		inl "!+++^"; Go to label 3 (char_back_end)
		inl "avd" ; restore temp value
		inl "<"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!++^"; Go to label 2 (char_back)
	inl "avd" ; restore temp value
	inl "$"

	char_back_end:
	; Store value.

	inl "a^" ; store temp
	inl "d!*-^" ; store label 4 (char_set)
	inl "d!+^" ; store 1
	inl "aaaaavdddddd^" ; store operation reg
	inl "aa" ; back to label
	inl "avd" ; restore value
	inl "?"

	; If operation is not 1 (2)
	inl "aavdd" ; set value
	char_set:
	; If operation is 1:
	inl "aa^dd" ; put char into value

	; Now we are currently in the label reg.
	; Go back to temp reg and store current memory cell.
	inl "a^d"

	inl "d" ; space for label
	inl "!^d" ; store zero to compare
	inl "aaaaavddddd^" ; store 4 to compare (matching register)
	inl "aa" ; go back
	inl "avd" ; Restore temp value
	char_forward:
		inl "a^d" ; store current cell temp
		inl "!*+^"; Go to label 5 (char_forward_back)
		inl "avd" ; restore temp value
		inl ">"

		; to go matching register + 1, store temp,
		; sub matching register, return back
		inl "ddd^"
		inl "av-^dvaaa"
	inl "?" ; equ

	; Goto
	inl "a^d" ; store current cell temp
	inl "!*^"; Go to label 4 (char_forward)
	inl "avd" ; restore temp value
	inl "$"
	char_forward_back:
	inl "aa<<v>>aaa" ; go to initial value, when started
ret

std_add:
	cmp std_second 0 std_add_stop ; is d zero? then stop
	add std_first 1 ; increase first and
	sub std_second 1 ; decrease second
	jmp std_add
	std_add_stop:
	mov std_result std_first
ret

; divmod algorithm
std_divide:
	add std_result 1
	mov std_i std_second
	std_divide_sub:
		cmp std_i 0 std_divide
		sub std_i 1
		cmp std_first 0 std_divide_exit
		sub std_first 1
	jmp std_divide_sub
	std_divide_exit:

	; Do offsets
	sub std_result 1
	add std_i 1


ret

std_mult:
	cmp std_second 0 std_mult_end
	mov std_i std_first
	std_mult_add:
		cmp std_i 0 std_mult_add_end
		add std_result 1
		sub std_i 1
		jmp std_mult_add
	std_mult_add_end:
	sub std_second 1
	jmp std_mult
	std_mult_end:
ret

std_end:
`
	};

	code.value = demos["std.casm"];
	</script>
</html>
